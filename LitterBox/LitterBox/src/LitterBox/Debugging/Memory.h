/*!************************************************************************
 \file			Memory.h
 \author		Ang Jiawei Jarrett
 \par DP email: a.jiaweijarrett@digipen.edu
 \par Course:	CSD2401A
 \date			22-09-2023
 \brief

 Copyright (C) 2023 DigiPen Institute of Technology. Reproduction or
 disclosure of this file or its contents without the prior written consent
 of DigiPen Institute of Technology is prohibited.
**************************************************************************/

#pragma once

#include <map>
#include "LitterBox/Core/System.h"

namespace LB 
{
    /*!***********************************************************************
     \brief

    *************************************************************************/
    class Memory : public ISystem 
    {
    public:
        /*!***********************************************************************
        \brief

        *************************************************************************/
        Memory();

        /*!***********************************************************************
        \brief

        *************************************************************************/
        void Initialize() override { SetSystemName("Memory System"); }

        /*!***********************************************************************
        \brief

        *************************************************************************/
        void Destroy() override;

        /*!***********************************************************************
        \brief

        *************************************************************************/
        template <typename T>
        T* Allocate();

        /*!***********************************************************************
        \brief

        *************************************************************************/
        template <typename T, typename... Args>
        T* Allocate(Args&&... args);

        /*!***********************************************************************
        \brief

        *************************************************************************/
        template <typename T>
        void Deallocate(T* ptr);

    private:
        /*!***********************************************************************
        \brief

        *************************************************************************/
        std::map<void*, size_t> allocs;
    };

    /*!***********************************************************************
    \brief

    *************************************************************************/
    extern Memory* MEMORY;
}

/***************************************************************************************************
*
* Template functions definitions
*
***************************************************************************************************/

namespace LB
{
    /*!***********************************************************************
    \brief

    *************************************************************************/
    template <typename T>
    T* Memory::Allocate()
    {
        T* ptr = new T;
        allocs[(void*)ptr] = sizeof(T);
        return ptr;
    }

    /*!***********************************************************************
    \brief

    *************************************************************************/
    template <typename T, typename... Args>
    T* Memory::Allocate(Args&&... args)
    {
        T* ptr = new T(std::forward<Args>(args)...);
        allocs[(void*)ptr] = sizeof(T);
        return ptr;
    }

    /*!***********************************************************************
    \brief

    *************************************************************************/
    template <typename T>
    void Memory::Deallocate(T* ptr)
    {
        auto it = allocs.find((void*)ptr);
        if (it != allocs.end()) {
            delete ptr;
            allocs.erase(it);
        }
        else
        {
            std::cerr << "Memory: Tried to dellocate non-existent ptr of size <" << it->second << " bytes>\n";
        }
    }
}
